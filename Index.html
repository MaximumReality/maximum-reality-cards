<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Maximum Reality Klondike Solitaire</title>
<style>
body {
    font-family: Arial, sans-serif;
    background-color: #ffffff;
    color: #000;
    margin: 0;
    padding: 20px;
}
h1 { text-align: center; }
button {
    padding: 10px 20px;
    margin: 5px;
    font-size: 16px;
    border-radius: 5px;
    cursor: pointer;
}
#deckCount { font-weight: bold; margin-left: 10px; }
#gameArea { position: relative; width: 100%; height: 80vh; margin-top: 20px; }

/* Piles */
.pile { width: 120px; height: 170px; position: absolute; border-radius: 8px; background-color: #f5f5f5; }
.foundation { top: 0; }
.stock { left: 10px; top: 0; }
.waste { left: 150px; top: 0; }
.tableau { top: 200px; }

/* Card */
.card {
    width: 120px;
    height: 170px;
    position: absolute;
    cursor: grab;
    perspective: 1000px;
    border-radius: 8px;
    z-index: 1;
    transition: top 0.3s ease, left 0.3s ease;
}
.card-inner {
    width: 100%;
    height: 100%;
    position: relative;
    transform-style: preserve-3d;
    transition: transform 0.6s;
}
.card.flipped .card-inner { transform: rotateY(180deg); }
.card img { width: 100%; height: 100%; position: absolute; top: 0; left: 0; object-fit: contain; backface-visibility: hidden; }
.card img.back { transform: rotateY(180deg); }
</style>
</head>
<body>

<h1>Maximum Reality Klondike Solitaire</h1>
<button id="resetBtn">Reset Game</button>
<button id="drawStockBtn">Draw Card</button>
<span id="deckCount">Deck: 52 cards</span>

<div id="gameArea">
    <div id="stock" class="pile stock"></div>
    <div id="waste" class="pile waste"></div>
    <div id="foundation0" class="pile foundation" style="left: 300px;"></div>
    <div id="foundation1" class="pile foundation" style="left: 450px;"></div>
    <div id="foundation2" class="pile foundation" style="left: 600px;"></div>
    <div id="foundation3" class="pile foundation" style="left: 750px;"></div>

    <div id="tableau0" class="pile tableau" style="left: 10px;"></div>
    <div id="tableau1" class="pile tableau" style="left: 150px;"></div>
    <div id="tableau2" class="pile tableau" style="left: 290px;"></div>
    <div id="tableau3" class="pile tableau" style="left: 430px;"></div>
    <div id="tableau4" class="pile tableau" style="left: 570px;"></div>
    <div id="tableau5" class="pile tableau" style="left: 710px;"></div>
    <div id="tableau6" class="pile tableau" style="left: 850px;"></div>
</div>

<script>
const githubBase = 'https://raw.githubusercontent.com/MaximumReality/maximum-reality-cards/main/';
const suits = ['hearts','diamonds','clubs','spades'];
const numbers = ['2','3','4','5','6','7','8','9','10'];
const faces = ['j','q','k','a'];
let deck=[], zIndexCounter=1;

let stock=[], waste=[], foundations=[[],[],[],[]], tableau=[[],[],[],[],[],[],[]];

// Create card element
function createCard(file, faceUp=true){
    const card = document.createElement('div'); card.className='card';
    card.style.zIndex=zIndexCounter++;
    const inner = document.createElement('div'); inner.className='card-inner';
    const back = document.createElement('img'); back.src=githubBase+'card-back.png'; back.classList.add('back');
    const front = document.createElement('img'); front.src=githubBase+file;
    inner.appendChild(back); inner.appendChild(front); card.appendChild(inner);
    if(faceUp) card.classList.add('flipped');
    card.dataset.file = file;
    card.dataset.faceUp = faceUp;
    return card;
}

// Build and shuffle deck
function buildDeck(){
    deck=[];
    for(let s of suits){
        for(let n of numbers) deck.push(`${n}_${s}.png`);
        for(let f of faces) deck.push(`${f}_${s}.png`);
    }
    shuffle(deck);
    document.getElementById('deckCount').textContent = `Deck: ${deck.length} cards`;
}

// Shuffle array
function shuffle(arr){ for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; } }

// Deal to tableau
function dealTableau(){
    const gameArea = document.getElementById('gameArea');
    for(let i=0;i<7;i++){
        for(let j=0;j<=i;j++){
            const cardFile = deck.pop();
            const card = createCard(cardFile,j===i);
            card.style.left = (10 + i*140)+'px';
            card.style.top = (200 + j*30)+'px';
            gameArea.appendChild(card);
            tableau[i].push(card);
            makeDraggable(card, i, tableau[i]);
        }
    }
    stock = deck.map(f=>createCard(f,false));
    stock.forEach(c=>{ c.style.left='10px'; c.style.top='0px'; document.getElementById('gameArea').appendChild(c); });
    updateDeckCount();
}

// Draw from stock
document.getElementById('drawStockBtn').addEventListener('click', ()=>{
    if(stock.length===0){
        stock = waste.reverse();
        waste=[];
        stock.forEach(c=>{ c.classList.remove('flipped'); c.dataset.faceUp=false; c.style.left='10px'; c.style.top='0px'; document.getElementById('gameArea').appendChild(c); });
    } else {
        const card = stock.pop();
        card.classList.add('flipped'); card.dataset.faceUp=true;
        card.style.left='150px'; card.style.top='0px';
        document.getElementById('gameArea').appendChild(card);
        waste.push(card);
    }
    updateDeckCount();
});

// Update deck count
function updateDeckCount(){ document.getElementById('deckCount').textContent = `Deck: ${stock.length} cards`; }

// Helper to check color
function isRed(card){
    return card.dataset.file.includes('hearts') || card.dataset.file.includes('diamonds');
}

// Drag-and-drop for tableau sequence with animation
function makeDraggable(card, pileIndex, pileArray){
    card.addEventListener('mousedown', e=>{
        if(card.dataset.faceUp==='false') return;
        const startX = e.clientX;
        const startY = e.clientY;
        const seqIndex = pileArray.indexOf(card);
        const sequence = pileArray.slice(seqIndex);
        sequence.forEach(c=>c.style.zIndex = zIndexCounter++);

        const offsets = sequence.map(c=>({
            x: c.offsetLeft,
            y: c.offsetTop
        }));

        function move(e){
            const dx = e.clientX - startX;
            const dy = e.clientY - startY;
            sequence.forEach((c,i)=>{
                c.style.left = offsets[i].x + dx + 'px';
                c.style.top = offsets[i].y + dy + 'px';
            });
        }

        function up(e){
            document.removeEventListener('mousemove',move);
            document.removeEventListener('mouseup',up);
            let placed=false;

            // Check tableau piles
            for(let i=0;i<7;i++){
                const pile = document.getElementById(`tableau${i}`);
                const rect = pile.getBoundingClientRect();
                const seqBottom = sequence[0].getBoundingClientRect();
                if(Math.abs(seqBottom.left - rect.left)<60 && Math.abs(seqBottom.top - rect.top)<300){
                    const targetPile = tableau[i];
                    if(targetPile.length===0 && sequence[0].dataset.file.startsWith('k')){
                        sequence.forEach((c,j)=>{
                            animateMove(c, parseInt(pile.style.left), 200 + (targetPile.length+j)*30);
                        });
                        targetPile.push(...sequence);
                        pileArray.splice(seqIndex, sequence.length);
                        autoFlipTop(pileArray);
                        placed=true;
                        break;
                    } else if(targetPile.length>0){
                        const topCard = targetPile[targetPile.length-1];
                        if(topCard.dataset.faceUp==='true' &&
                           parseInt(topCard.dataset.file.split('_')[0]) === parseInt(sequence[0].dataset.file.split('_')[0])+1 &&
                           isRed(topCard)!==isRed(sequence[0])){
                            sequence.forEach((c,j)=>{
                                animateMove(c, parseInt(pile.style.left), 200 + (targetPile.length+j)*30);
                            });
                            targetPile.push(...sequence);
                            pileArray.splice(seqIndex, sequence.length);
                            autoFlipTop(pileArray);
                            placed=true;
                            break;
                        }
                    }
                }
            }

            if(!placed){
                // Return sequence to original pile with animation
                sequence.forEach((c,i)=>{
                    animateMove(c, offsets[i].x, offsets[i].y);
                });
            }
            checkWin();
        }

        document.addEventListener('mousemove',move);
        document.addEventListener('mouseup',up);
    });
}

// Smooth move animation
function animateMove(card, x, y){
    card.style.transition='top 0.3s ease,left 0.3s ease';
    card.style.left = x+'px';
    card.style.top = y+'px';
    setTimeout(()=>{ card.style.transition=''; }, 300);
}

// Auto-flip top card if face-down with animation
function autoFlipTop(pile){
    if(pile.length===0) return;
    const top = pile[pile.length-1];
    if(top.dataset.faceUp==='false'){
        top.classList.add('flipped'); top.dataset.faceUp=true;
    }
}

// Check win
function checkWin(){
    if(foundations.every(f=>f.length===13)) alert("You Win!");
}

// Reset
document.getElementById('resetBtn').addEventListener('click', ()=>{
    document.getElementById('gameArea').innerHTML='';
    tableau=[[],[],[],[],[],[],[]]; foundations=[[],[],[],[]]; stock=[]; waste=[];
    buildDeck(); dealTableau();
});

// Initialize
buildDeck();
dealTableau();
</script>

</body>
</html>
